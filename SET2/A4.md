# 1. Алгоритм для инверсий
## 1.1 Разработанный алгоритм
```c++
#include <iostream>
#include <vector>

size_t Merge(std::vector<int>& arr, const int l, const int mid, const int r) {
  const std::vector<int> left_intervals(arr.begin() + l, arr.begin() + mid + 1);
  const std::vector<int> right_intervals(arr.begin() + mid + 1, arr.begin() + r + 1);

  int i = 0;
  int j = 0;
  int cur = l;
  size_t res = 0;

  while (i < left_intervals.size() && j < right_intervals.size()) {
    if (left_intervals[i] <= right_intervals[j]) {
      arr[cur++] = left_intervals[i++];
    } else {
      arr[cur++] = right_intervals[j++];
      res += left_intervals.size() - i;
    }
  }

  while (i < left_intervals.size()) {
    arr[cur++] = left_intervals[i++];
  }
  while (j < right_intervals.size()) {
    arr[cur++] = right_intervals[j++];
  }
  return res;
}

size_t MergeSort(std::vector<int>& arr, int l, int r) {
  if (l >= r) {
    return 0;
  }
  size_t k = 0;
  
  const int m = l + (r - l) / 2;
  k += MergeSort(arr, l, m);
  k += MergeSort(arr, m+1, r);
  k += Merge(arr, l, m, r);
  return k;
}

int main() {
  std::vector<int> arr = {1,3,4,2,5};
  std::cout << MergeSort(arr, 0, arr.size() - 1);
}
```
---
## 1.2 Шаги Divide, Conquer и Combine
Divide. Рекурсивно разделяем массив на две половины:
```c++
  const int m = l + (r - l) / 2;
  k += MergeSort(arr, l, m);
  k += MergeSort(arr, m+1, r);
```

---

Conquer. После рекурсивного вызова MergeSort для левой и правой частей, мы уже знаем количество инверсий внутри каждого подмассива.
Для единичного элемента l >= r инверсий нет: return 0.
Для подмассива из 2 элементов инверсии считаются в шаге Combine.

---

Combine. Функция *Merge* сливает два отсортированных массива в один, и подсчитывает количество инверсий между подмассивами

```c++
if (left_intervals[i] <= right_intervals[j]) {
    arr[cur++] = left_intervals[i++];
} else {
    arr[cur++] = right_intervals[j++];
    res += left_intervals.size() - i; // количество инверсий
}
```
Также на этапе MergeSort мы складываем инверсии в правой и левой частях, а также между ними. 

```c++
  k += MergeSort(arr, l, m);
  k += MergeSort(arr, m+1, r);
  k += Merge(arr, l, m, r);
  return k;
```

---

## 1.3 Рекуррентное соотношение и сложность

Асимптотика совпадает с MergeSort.

$$T(n) = 2 \cdot T(\frac{n}{2}) + O(n)$$

По мастер-теореме:

$$T(n) = O(n \log n)$$

---

## 1.4 Возвращает ли алгоритм минимальное количество инверсий?
Да. Обоснование:

Алгоритм считает каждую инверсию ровно один раз:

1. Внутри левого подмассива

2. Внутри правого подмассива

3. Между левым и правым подмассивами в Merge

Любая инверсия $a_i$ > $a_j,$ с i < j будет либо внутри одного подмассива, либо между двумя подмассивами, и учтена в res.

Алгоритм не считает лишние инверсии и не пропускает ни одной, поэтому результат — минимальное число перестановок, необходимых для сортировки массива (точно равное числу инверсий).

---

# 2. Значительные инверсии
## 2.1 Разработанный алгоритм
```c++
size_t MergeSignificant(std::vector<int>& arr, const int l, const int mid, const int r) {
  const std::vector<int> left_intervals(arr.begin() + l, arr.begin() + mid + 1);
  const std::vector<int> right_intervals(arr.begin() + mid + 1, arr.begin() + r + 1);

  size_t res = 0;
  int k = 0;
  for (int i = 0; i < left_intervals.size(); i++) {
    while (k < right_intervals.size() && left_intervals[i] > 2LL * right_intervals[k]) {
      k++;
    }
    res += k;
  }

  int i = 0;
  int j = 0;
  int cur = l;

  while (i < left_intervals.size() && j < right_intervals.size()) {
    if (left_intervals[i] <= right_intervals[j]) {
      arr[cur++] = left_intervals[i++];
    } else {
      arr[cur++] = right_intervals[j++];
    }
  }

  while (i < left_intervals.size()) {
    arr[cur++] = left_intervals[i++];
  }
  while (j < right_intervals.size()) {
    arr[cur++] = right_intervals[j++];
  }
  return res;
}

size_t MergeSortSignificant(std::vector<int>& arr, const int l, const int r) {
  if (l >= r) {
    return 0;
  }
  const int m = l + (r - l) / 2;
  size_t k = 0;
  k += MergeSortSignificant(arr, l, m);
  k += MergeSortSignificant(arr, m + 1, r);
  k += MergeSignificant(arr, l, m, r);
  return k;
}
```

## 2.2 Изменения в подсчете инверсий
```c++
  size_t res = 0;
  int k = 0;
  for (int i = 0; i < left_intervals.size(); i++) {
    while (k < right_intervals.size() && left_intervals[i] > 2LL * right_intervals[k]) {
      k++;
    }
    res += k;
  }
```

---

## 2.3 Обоснование корректности и временной сложности.
Пусть первые k элементов правого подмассива образуют инверсию с i-ым элементов левого подмассива.

Тогда т.к. на этапе Merge и левая и правая части отсортированы, то все первые k элементов правого подмассива образуют значительную инверсию и со всеми последующими элементами левого подмассива после i (и возможно с некоторыми следующими элементами правого подмассива, которые мы узнаем в цикле while).

---

Асимптотика не меняется, т.к. нерекурсивная часть работы все еще O(n). Добавились вложенные циклы, но они все еще проходят лишь однажды каждый элемент левого и правого подмассива.
