#include <algorithm>
#include <iostream>
#include <vector>

int Alg1(const std::vector<int>& A) {
  int c = 0;
  int ind = -1;

  for (int i = 0; i < A.size(); i++) {
    int c1 = 0;
    for (int j = 0; j < A.size(); j++) {
      if (A[i] == A[j]) {
        c1 = c1 + 1;
      }
    }

    if (c1 > c) {
      c = c1;
      ind = i;
    }
  }

  if (c > A.size() / 2) {
    return ind;
  }
  return -1;
}

int Alg2(const std::vector<int>& A) {
  int c = 1;
  int ind = 0;

  for (int i = 1; i < A.size(); i++) {
    if (A[ind] == A[i]) {
      c = c + 1;
    } else {
      c = c - 1;
    }

    if (c == 0) {
      ind = i;
      c = 1;
    }
  }

  c = 0;
  for (int i = 0; i < A.size(); i++) {
    if (A[ind] == A[i]) {
      c++;
    }
  }
  if (c > A.size() / 2) {
    return ind;
  }
  return -1;
}

int Alg3(std::vector<int>& A) {
  if (A.size() == 1) {
    return 0;
  }

  int c = 1;
  std::vector<int> copy = A;
  std::ranges::sort(copy);

  for (int i = 1; i < copy.size(); i++) {
    if (copy[i - 1] == copy[i]) {
      c = c + 1;
    } else {
      c = 1;
    }
    if (c > copy.size() / 2) {
      for (int j = 0; j < A.size(); j++) {
        if (A[j] == copy[i - 1]) {
          return j;
        }
      }
    }
  }

  return -1;
}

// 1.1 Не согласен с утверждением. Результаты 1 и 3 обычно алгоритмов совпадают, а 2 может отличаться.
// 1 и 3 алгоритмы пытаются найти элемент, который встречается больше, чем n / 2 раз.
// 2 же - ищет только кандидата в мажоритарный элемент, но не проверяет, действительно ли он встречается > n/2 раз
// 1.2 Если искомый элемент есть, то алгоритмы работают корректно.
// Пример A = [1, 1, 1, 2]:
// Alg1:
// i = 0:
// c1 = 1 -> c1 = 2 -> c1 = 3 -> c1 = 3;
// c = 3, ind = 0;
// ...
// i = 3:
// с1 = 0 -> с1 = 0 -> с1 = 0 -> с1 = 1;
// c= 3, ind = 0;
// result == 1;

// Alg2:
// c = 2 -> c = 3 -> c = 2;
// result == 1

// Alg3:
// sorted(A) == [1, 1, 1, 2];
// c = 2 -> c = 3 -> c = 3;
// result == 1;

// Если искомого элемента нет, то 1 и 3 алгоритмы вызывают ошибки, т.к. не всегда возвращают значения.
// Пример A = [1, 1, 2, 2]:
// Alg1 и Alg3 - ошибки;
// Alg2:
// c = 1 -> c = 2 -> c = 1 -> c = 0;
// ind = 3, c = 1;
// result == 2;


// 2 Внутренний цикл Alg1 работает за O(n), внешний - за O(n).
// Тогда в целом Alg1 работает за O(n^2);

// Цикл Alg2 выполняет за n-1 итераций, т.е. O(n), все остальные операции за константу.
// Тогда в целом Alg2 работает за O(n)

// Цикл Alg3 выполняется максимум за n-1 операцию. Допустим sort работает за O(nLogn).
// Тогда в целом Alg3 работает за O(nLogn + n) = O(nLogn)


// 3 Будем возвращать не сам элемент, а его индекс. Если искомого элемента нет, то -1.
// В такой реализации можем работать и с отрицательными числами.
// Тогда все 3 алгоритма будут решать одну задачу и не вызывать ошибок (индекс может отличаться, но указывать на одно и то же значение).
// Изменения: Во всех местах, где возвращаем элемент (A[i-1], A[ind]...) возвращаем индекс (i-1, ind...)
// В стиле stl можем возвращать итераторы (потребует больше изменений в сам код).
// Alg1:
// В последнем if-е добавим else { return -1; }

// Alg2:
// Можем перед return проитерироваться по циклу и проверить, действительно ли элемент встречается > c/2 раз
// (Наверное можно и без второго прохода, но и так норм, будет O(n))
// Если да, то в самом return возвращаем ind, а не A[ind], иначе -1.

// Alg3:
// Изменим со строки c = 1;
// std::vector<int> copy = A;
// std::ranges::sort(copy);
//
// for (int i = 1; i < copy.size(); i++) {
//   if (copy[i - 1] == copy[i]) {
//     c = c + 1;
//   } else {
//     c = 1;
//   }
//   if (c > copy.size() / 2) {
//     for (int j = 0; j < A.size(); j++) {
//       if (A[j] == copy[i - 1]) {
//         return j;
//       }
//     }
//   }
// }
//
// return -1;
// Т.е. итерируемся по копии и пытаемся найти элемент, встречающийся > n/2 раз.
// Если находим, то ищем его индекс в исходном массиве A. Если же мажоритарного нет, возвращаем -1

// 4 Alg1: просто добавили 1 операцию вне цикла, на асимптотику не влияет - O(n).
// Alg2: Добавили еще один цикл по n, но не вложенный, т.е. O(n+n) = O(n).
// Alg3: Добавили один ретерн вне цикла, добавили копию, добавили вложенный цикл.
// Копия O(n) так что не влияет, вложенный цикл отрабатывает только <= 1 раз, поэтому все еще O(n).
// В итоге сортировка все еще вносит самый большой вклад. Асимптотика O(nLogn)

int main() {
  std::vector<int> A;

  // 1. Простой случай: мажоритарный элемент есть
  A = {1, 2, 2};
  std::cout << Alg1(A) << " " << Alg2(A) << " " << Alg3(A) << "\n";
  // ожидаем индекс числа 2 (1 или 2 в зависимости от реализации)

  // 2. Пустой массив
  A = {};
  std::cout << Alg1(A) << " " << Alg2(A) << " " << Alg3(A) << "\n";
  // ожидаем -1 -1 -1

  // 3. Массив из одного элемента
  A = {5};
  std::cout << Alg1(A) << " " << Alg2(A) << " " << Alg3(A) << "\n";
  // ожидаем 0 0 0

  // 4. Нет мажоритарного элемента
  A = {1, 2, 3, 4};
  std::cout << Alg1(A) << " " << Alg2(A) << " " << Alg3(A) << "\n";
  // ожидаем -1 -1 -1

  // 5. Несколько чисел с одинаковой частотой, но < n/2
  A = {1, 2, 1, 2, 3};
  std::cout << Alg1(A) << " " << Alg2(A) << " " << Alg3(A) << "\n";
  // ожидаем -1 -1 -1

  // 6. Мажоритарный элемент в начале
  A = {7, 7, 7, 1, 2};
  std::cout << Alg1(A) << " " << Alg2(A) << " " << Alg3(A) << "\n";
  // ожидаем индекс одной из 7

  // 7. Мажоритарный элемент в случайной позиции
  A = {1, -7, 1, -7, 2, -7, -7};
  std::cout << Alg1(A) << " " << Alg2(A) << " " << Alg3(A) << "\n";
  // ожидаем индекс одной из -7
}
